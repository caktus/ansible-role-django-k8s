---
# For simplicity, even though the k8s module will use K8S_AUTH_API_KEY if set, we
# retrieve it from the environment ourselves at the start of the play so we know
# if we should try to create the namespace and service account or not. This also
# allows us to support setting k8s_auth_api_key through an Ansible variable or
# environment variable.
- name: Set k8s_auth_api_key from environment variable
  set_fact:
    k8s_auth_api_key: "{{ ansible_env.K8S_AUTH_API_KEY }}"
  when: ansible_env.K8S_AUTH_API_KEY is defined

# Does the user need to set k8s_auth_host?
- when: not k8s_auth_host
  fail:
    msg: "k8s_auth_host must be set. Please see the role documentation."

# FROM here on, always specify
#
#          host: "{{ k8s_auth_host }}"
#
# when communicating with the cluster. This makes sure we're talking to the right one.

# Does the user need to set k8s_auth_ssl_ca_cert?
- when: not k8s_auth_ssl_ca_cert
  block:
    - command: kubectl config view --minify=true -o jsonpath='{.clusters[0].cluster.certificate-authority-data}' --raw
      register: data_command
    - debug:
         msg: |
           1) Create a file (maybe k8s_auth_ssl_ca_cert.txt) and set contents to
           {{ data_command.stdout | b64decode }}
           with all indentation removed. (This does not need to be secret.)
           2) Set k8s_auth_ssl_ca_cert to the path to the file.
           3) Run again after doing that

# Does the user need to set k8s_auth_api_key?
- when: not k8s_auth_api_key
  block:
  - name: Create/update namespace (needed for deploy account)
    k8s:
      definition: "{{ lookup('template', 'namespace.yaml.j2') }}"
      state: present
      host: "{{ k8s_auth_host }}"
      # Ensure we see any failures in CI
      wait: yes
      validate:
        fail_on_error: yes
        strict: yes

  - name: Create/update deploy account
    k8s:
      definition: "{{ lookup('template', 'deploy_account.yaml.j2') }}"
      state: present
      host: "{{ k8s_auth_host }}"
      # Ensure we see any failures in CI
      wait: yes
      validate:
        fail_on_error: yes
        strict: yes
    register: deploy_account

  - set_fact:
      deploy_account_name: "{{ deploy_account.result.results.0.result.secrets.0.name }}"

  - name: Get deploy account secret (contains secret token=k8s_auth_api_key)
    k8s_info:
      kind: Secret
      namespace: "{{ k8s_namespace }}"
      name: "{{ deploy_account_name }}"
      host: "{{ k8s_auth_host }}"
    register: deploy_account_secret

  - debug:
      msg: |
        # Set a variable as follows:
        k8s_auth_api_key: "{{ deploy_account_secret.resources.0.data.token | b64decode }}"
        # THIS MUST BE KEPT SECRET, so encrypt the entry or the variables file.
        # Then run again.

# Did we have to show the user some settings that needed to be made?
- when: not k8s_auth_ssl_ca_cert or not k8s_auth_api_key
  fail:
    msg: "Please follow the instructions above, then run again"

# FROM here on, we have the information we need to use the deploy account instead of
# the user's own credentials to deploy etc in our Kubernetes cluster.  api_key and
# ca_cert provide authentication and authorization. host is to specify which cluster
# to talk to.

- name: Create/update templates in Kubernetes
  k8s:
    api_key: "{{ k8s_auth_api_key }}"
    ca_cert: "{{ k8s_auth_ssl_ca_cert }}"
    host: "{{ k8s_auth_host }}"
    definition: "{{ lookup('template', item['name']) }}"
    state: "{{ item['state'] }}"
    # Ensure we see any failures in CI
    wait: yes
    validate:
      fail_on_error: yes
      strict: yes
  with_items: "{{ k8s_templates }}"
